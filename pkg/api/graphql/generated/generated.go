// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"soko/pkg/models"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Application struct {
		LastCommit func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	Bug struct {
		Assignee  func(childComplexity int) int
		Component func(childComplexity int) int
		Id        func(childComplexity int) int
		Product   func(childComplexity int) int
		Status    func(childComplexity int) int
		Summary   func(childComplexity int) int
	}

	Category struct {
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
		Packages    func(childComplexity int) int
	}

	ChangedFile struct {
		ChangeType func(childComplexity int) int
		Path       func(childComplexity int) int
	}

	ChangedFiles struct {
		Added    func(childComplexity int) int
		Deleted  func(childComplexity int) int
		Modified func(childComplexity int) int
	}

	Commit struct {
		AuthorDate       func(childComplexity int) int
		AuthorEmail      func(childComplexity int) int
		AuthorName       func(childComplexity int) int
		ChangedFiles     func(childComplexity int) int
		ChangedPackages  func(childComplexity int) int
		ChangedVersions  func(childComplexity int) int
		CommitterDate    func(childComplexity int) int
		CommitterEmail   func(childComplexity int) int
		CommitterName    func(childComplexity int) int
		Id               func(childComplexity int) int
		KeywordChanges   func(childComplexity int) int
		Message          func(childComplexity int) int
		PrecedingCommits func(childComplexity int) int
	}

	GitHubPullRequestFileNode struct {
		Additions func(childComplexity int) int
		Deletions func(childComplexity int) int
		Path      func(childComplexity int) int
	}

	GitHubPullRequestLabelNode struct {
		Color func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	GithubPullRequest struct {
		Author      func(childComplexity int) int
		CiState     func(childComplexity int) int
		CiStateLink func(childComplexity int) int
		Closed      func(childComplexity int) int
		Comments    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Files       func(childComplexity int) int
		Id          func(childComplexity int) int
		Labels      func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Url         func(childComplexity int) int
	}

	KeywordChange struct {
		Added      func(childComplexity int) int
		All        func(childComplexity int) int
		Commit     func(childComplexity int) int
		CommitId   func(childComplexity int) int
		Id         func(childComplexity int) int
		Package    func(childComplexity int) int
		PackageId  func(childComplexity int) int
		Stabilized func(childComplexity int) int
		Version    func(childComplexity int) int
		VersionId  func(childComplexity int) int
	}

	Maintainer struct {
		Email    func(childComplexity int) int
		Name     func(childComplexity int) int
		Restrict func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	Mask struct {
		Author      func(childComplexity int) int
		AuthorEmail func(childComplexity int) int
		Date        func(childComplexity int) int
		Reason      func(childComplexity int) int
		Versions    func(childComplexity int) int
	}

	OutdatedPackage struct {
		Atom          func(childComplexity int) int
		GentooVersion func(childComplexity int) int
		NewestVersion func(childComplexity int) int
	}

	Package struct {
		Atom                func(childComplexity int) int
		Bugs                func(childComplexity int) int
		Category            func(childComplexity int) int
		Commits             func(childComplexity int) int
		Longdescription     func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Name                func(childComplexity int) int
		Outdated            func(childComplexity int) int
		PkgCheckResults     func(childComplexity int) int
		PrecedingCommits    func(childComplexity int) int
		PullRequests        func(childComplexity int) int
		ReverseDependencies func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	PkgCheckResult struct {
		Atom     func(childComplexity int) int
		CPV      func(childComplexity int) int
		Category func(childComplexity int) int
		Class    func(childComplexity int) int
		Message  func(childComplexity int) int
		Package  func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	Query struct {
		AddedPackages      func(childComplexity int, limit *int) int
		Application        func(childComplexity int) int
		Categories         func(childComplexity int, name *string, description *string) int
		Category           func(childComplexity int, name *string, description *string) int
		Commit             func(childComplexity int, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) int
		Commits            func(childComplexity int, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) int
		KeywordedVersions  func(childComplexity int, limit *int, arch *string) int
		LastCommitTime     func(childComplexity int) int
		Mask               func(childComplexity int, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) int
		Masks              func(childComplexity int, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) int
		OutdatedPackage    func(childComplexity int, atom *string, gentooVersion *string, newestVersion *string) int
		OutdatedPackages   func(childComplexity int, atom *string, gentooVersion *string, newestVersion *string) int
		Package            func(childComplexity int, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) int
		Packages           func(childComplexity int, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) int
		PkgCheckResult     func(childComplexity int, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) int
		PkgCheckResults    func(childComplexity int, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) int
		StabilizedVersions func(childComplexity int, limit *int, arch *string) int
		UpdatedVersions    func(childComplexity int, limit *int) int
		Useflag            func(childComplexity int, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) int
		Useflags           func(childComplexity int, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) int
		Version            func(childComplexity int, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) int
		Versions           func(childComplexity int, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) int
	}

	ReverseDependency struct {
		Atom                     func(childComplexity int) int
		Condition                func(childComplexity int) int
		Id                       func(childComplexity int) int
		ReverseDependencyAtom    func(childComplexity int) int
		ReverseDependencyVersion func(childComplexity int) int
		Type                     func(childComplexity int) int
	}

	Useflag struct {
		Description func(childComplexity int) int
		Id          func(childComplexity int) int
		Name        func(childComplexity int) int
		Package     func(childComplexity int) int
		Scope       func(childComplexity int) int
		UseExpand   func(childComplexity int) int
	}

	Version struct {
		Atom            func(childComplexity int) int
		Category        func(childComplexity int) int
		Commits         func(childComplexity int) int
		Dependencies    func(childComplexity int) int
		Description     func(childComplexity int) int
		EAPI            func(childComplexity int) int
		Homepage        func(childComplexity int) int
		Id              func(childComplexity int) int
		Keywords        func(childComplexity int) int
		License         func(childComplexity int) int
		Masks           func(childComplexity int) int
		Package         func(childComplexity int) int
		PkgCheckResults func(childComplexity int) int
		Properties      func(childComplexity int) int
		Restricts       func(childComplexity int) int
		Slot            func(childComplexity int) int
		Subslot         func(childComplexity int) int
		Useflags        func(childComplexity int) int
		Version         func(childComplexity int) int
	}
}

type QueryResolver interface {
	Category(ctx context.Context, name *string, description *string) (*models.Category, error)
	Categories(ctx context.Context, name *string, description *string) ([]*models.Category, error)
	Commit(ctx context.Context, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) (*models.Commit, error)
	Commits(ctx context.Context, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) ([]*models.Commit, error)
	Mask(ctx context.Context, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) (*models.Mask, error)
	Masks(ctx context.Context, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) ([]*models.Mask, error)
	OutdatedPackage(ctx context.Context, atom *string, gentooVersion *string, newestVersion *string) (*models.OutdatedPackages, error)
	OutdatedPackages(ctx context.Context, atom *string, gentooVersion *string, newestVersion *string) ([]*models.OutdatedPackages, error)
	PkgCheckResult(ctx context.Context, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) (*models.PkgCheckResult, error)
	PkgCheckResults(ctx context.Context, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) ([]*models.PkgCheckResult, error)
	Package(ctx context.Context, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) (*models.Package, error)
	Packages(ctx context.Context, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) ([]*models.Package, error)
	Useflag(ctx context.Context, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) (*models.Useflag, error)
	Useflags(ctx context.Context, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) ([]*models.Useflag, error)
	Version(ctx context.Context, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) (*models.Version, error)
	Versions(ctx context.Context, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) ([]*models.Version, error)
	Application(ctx context.Context) (*models.Application, error)
	LastCommitTime(ctx context.Context) (*time.Time, error)
	AddedPackages(ctx context.Context, limit *int) ([]*models.Package, error)
	UpdatedVersions(ctx context.Context, limit *int) ([]*models.Version, error)
	StabilizedVersions(ctx context.Context, limit *int, arch *string) ([]*models.Version, error)
	KeywordedVersions(ctx context.Context, limit *int, arch *string) ([]*models.Version, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Application.LastCommit":
		if e.complexity.Application.LastCommit == nil {
			break
		}

		return e.complexity.Application.LastCommit(childComplexity), true

	case "Application.LastUpdate":
		if e.complexity.Application.LastUpdate == nil {
			break
		}

		return e.complexity.Application.LastUpdate(childComplexity), true

	case "Application.Version":
		if e.complexity.Application.Version == nil {
			break
		}

		return e.complexity.Application.Version(childComplexity), true

	case "Bug.Assignee":
		if e.complexity.Bug.Assignee == nil {
			break
		}

		return e.complexity.Bug.Assignee(childComplexity), true

	case "Bug.Component":
		if e.complexity.Bug.Component == nil {
			break
		}

		return e.complexity.Bug.Component(childComplexity), true

	case "Bug.Id":
		if e.complexity.Bug.Id == nil {
			break
		}

		return e.complexity.Bug.Id(childComplexity), true

	case "Bug.Product":
		if e.complexity.Bug.Product == nil {
			break
		}

		return e.complexity.Bug.Product(childComplexity), true

	case "Bug.Status":
		if e.complexity.Bug.Status == nil {
			break
		}

		return e.complexity.Bug.Status(childComplexity), true

	case "Bug.Summary":
		if e.complexity.Bug.Summary == nil {
			break
		}

		return e.complexity.Bug.Summary(childComplexity), true

	case "Category.Description":
		if e.complexity.Category.Description == nil {
			break
		}

		return e.complexity.Category.Description(childComplexity), true

	case "Category.Name":
		if e.complexity.Category.Name == nil {
			break
		}

		return e.complexity.Category.Name(childComplexity), true

	case "Category.Packages":
		if e.complexity.Category.Packages == nil {
			break
		}

		return e.complexity.Category.Packages(childComplexity), true

	case "ChangedFile.ChangeType":
		if e.complexity.ChangedFile.ChangeType == nil {
			break
		}

		return e.complexity.ChangedFile.ChangeType(childComplexity), true

	case "ChangedFile.Path":
		if e.complexity.ChangedFile.Path == nil {
			break
		}

		return e.complexity.ChangedFile.Path(childComplexity), true

	case "ChangedFiles.Added":
		if e.complexity.ChangedFiles.Added == nil {
			break
		}

		return e.complexity.ChangedFiles.Added(childComplexity), true

	case "ChangedFiles.Deleted":
		if e.complexity.ChangedFiles.Deleted == nil {
			break
		}

		return e.complexity.ChangedFiles.Deleted(childComplexity), true

	case "ChangedFiles.Modified":
		if e.complexity.ChangedFiles.Modified == nil {
			break
		}

		return e.complexity.ChangedFiles.Modified(childComplexity), true

	case "Commit.AuthorDate":
		if e.complexity.Commit.AuthorDate == nil {
			break
		}

		return e.complexity.Commit.AuthorDate(childComplexity), true

	case "Commit.AuthorEmail":
		if e.complexity.Commit.AuthorEmail == nil {
			break
		}

		return e.complexity.Commit.AuthorEmail(childComplexity), true

	case "Commit.AuthorName":
		if e.complexity.Commit.AuthorName == nil {
			break
		}

		return e.complexity.Commit.AuthorName(childComplexity), true

	case "Commit.ChangedFiles":
		if e.complexity.Commit.ChangedFiles == nil {
			break
		}

		return e.complexity.Commit.ChangedFiles(childComplexity), true

	case "Commit.ChangedPackages":
		if e.complexity.Commit.ChangedPackages == nil {
			break
		}

		return e.complexity.Commit.ChangedPackages(childComplexity), true

	case "Commit.ChangedVersions":
		if e.complexity.Commit.ChangedVersions == nil {
			break
		}

		return e.complexity.Commit.ChangedVersions(childComplexity), true

	case "Commit.CommitterDate":
		if e.complexity.Commit.CommitterDate == nil {
			break
		}

		return e.complexity.Commit.CommitterDate(childComplexity), true

	case "Commit.CommitterEmail":
		if e.complexity.Commit.CommitterEmail == nil {
			break
		}

		return e.complexity.Commit.CommitterEmail(childComplexity), true

	case "Commit.CommitterName":
		if e.complexity.Commit.CommitterName == nil {
			break
		}

		return e.complexity.Commit.CommitterName(childComplexity), true

	case "Commit.Id":
		if e.complexity.Commit.Id == nil {
			break
		}

		return e.complexity.Commit.Id(childComplexity), true

	case "Commit.KeywordChanges":
		if e.complexity.Commit.KeywordChanges == nil {
			break
		}

		return e.complexity.Commit.KeywordChanges(childComplexity), true

	case "Commit.Message":
		if e.complexity.Commit.Message == nil {
			break
		}

		return e.complexity.Commit.Message(childComplexity), true

	case "Commit.PrecedingCommits":
		if e.complexity.Commit.PrecedingCommits == nil {
			break
		}

		return e.complexity.Commit.PrecedingCommits(childComplexity), true

	case "GitHubPullRequestFileNode.Additions":
		if e.complexity.GitHubPullRequestFileNode.Additions == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Additions(childComplexity), true

	case "GitHubPullRequestFileNode.Deletions":
		if e.complexity.GitHubPullRequestFileNode.Deletions == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Deletions(childComplexity), true

	case "GitHubPullRequestFileNode.Path":
		if e.complexity.GitHubPullRequestFileNode.Path == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Path(childComplexity), true

	case "GitHubPullRequestLabelNode.Color":
		if e.complexity.GitHubPullRequestLabelNode.Color == nil {
			break
		}

		return e.complexity.GitHubPullRequestLabelNode.Color(childComplexity), true

	case "GitHubPullRequestLabelNode.Name":
		if e.complexity.GitHubPullRequestLabelNode.Name == nil {
			break
		}

		return e.complexity.GitHubPullRequestLabelNode.Name(childComplexity), true

	case "GithubPullRequest.Author":
		if e.complexity.GithubPullRequest.Author == nil {
			break
		}

		return e.complexity.GithubPullRequest.Author(childComplexity), true

	case "GithubPullRequest.CiState":
		if e.complexity.GithubPullRequest.CiState == nil {
			break
		}

		return e.complexity.GithubPullRequest.CiState(childComplexity), true

	case "GithubPullRequest.CiStateLink":
		if e.complexity.GithubPullRequest.CiStateLink == nil {
			break
		}

		return e.complexity.GithubPullRequest.CiStateLink(childComplexity), true

	case "GithubPullRequest.Closed":
		if e.complexity.GithubPullRequest.Closed == nil {
			break
		}

		return e.complexity.GithubPullRequest.Closed(childComplexity), true

	case "GithubPullRequest.Comments":
		if e.complexity.GithubPullRequest.Comments == nil {
			break
		}

		return e.complexity.GithubPullRequest.Comments(childComplexity), true

	case "GithubPullRequest.CreatedAt":
		if e.complexity.GithubPullRequest.CreatedAt == nil {
			break
		}

		return e.complexity.GithubPullRequest.CreatedAt(childComplexity), true

	case "GithubPullRequest.Files":
		if e.complexity.GithubPullRequest.Files == nil {
			break
		}

		return e.complexity.GithubPullRequest.Files(childComplexity), true

	case "GithubPullRequest.Id":
		if e.complexity.GithubPullRequest.Id == nil {
			break
		}

		return e.complexity.GithubPullRequest.Id(childComplexity), true

	case "GithubPullRequest.Labels":
		if e.complexity.GithubPullRequest.Labels == nil {
			break
		}

		return e.complexity.GithubPullRequest.Labels(childComplexity), true

	case "GithubPullRequest.Title":
		if e.complexity.GithubPullRequest.Title == nil {
			break
		}

		return e.complexity.GithubPullRequest.Title(childComplexity), true

	case "GithubPullRequest.UpdatedAt":
		if e.complexity.GithubPullRequest.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubPullRequest.UpdatedAt(childComplexity), true

	case "GithubPullRequest.Url":
		if e.complexity.GithubPullRequest.Url == nil {
			break
		}

		return e.complexity.GithubPullRequest.Url(childComplexity), true

	case "KeywordChange.Added":
		if e.complexity.KeywordChange.Added == nil {
			break
		}

		return e.complexity.KeywordChange.Added(childComplexity), true

	case "KeywordChange.All":
		if e.complexity.KeywordChange.All == nil {
			break
		}

		return e.complexity.KeywordChange.All(childComplexity), true

	case "KeywordChange.Commit":
		if e.complexity.KeywordChange.Commit == nil {
			break
		}

		return e.complexity.KeywordChange.Commit(childComplexity), true

	case "KeywordChange.CommitId":
		if e.complexity.KeywordChange.CommitId == nil {
			break
		}

		return e.complexity.KeywordChange.CommitId(childComplexity), true

	case "KeywordChange.Id":
		if e.complexity.KeywordChange.Id == nil {
			break
		}

		return e.complexity.KeywordChange.Id(childComplexity), true

	case "KeywordChange.Package":
		if e.complexity.KeywordChange.Package == nil {
			break
		}

		return e.complexity.KeywordChange.Package(childComplexity), true

	case "KeywordChange.PackageId":
		if e.complexity.KeywordChange.PackageId == nil {
			break
		}

		return e.complexity.KeywordChange.PackageId(childComplexity), true

	case "KeywordChange.Stabilized":
		if e.complexity.KeywordChange.Stabilized == nil {
			break
		}

		return e.complexity.KeywordChange.Stabilized(childComplexity), true

	case "KeywordChange.Version":
		if e.complexity.KeywordChange.Version == nil {
			break
		}

		return e.complexity.KeywordChange.Version(childComplexity), true

	case "KeywordChange.VersionId":
		if e.complexity.KeywordChange.VersionId == nil {
			break
		}

		return e.complexity.KeywordChange.VersionId(childComplexity), true

	case "Maintainer.Email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.Name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Maintainer.Restrict":
		if e.complexity.Maintainer.Restrict == nil {
			break
		}

		return e.complexity.Maintainer.Restrict(childComplexity), true

	case "Maintainer.Type":
		if e.complexity.Maintainer.Type == nil {
			break
		}

		return e.complexity.Maintainer.Type(childComplexity), true

	case "Mask.Author":
		if e.complexity.Mask.Author == nil {
			break
		}

		return e.complexity.Mask.Author(childComplexity), true

	case "Mask.AuthorEmail":
		if e.complexity.Mask.AuthorEmail == nil {
			break
		}

		return e.complexity.Mask.AuthorEmail(childComplexity), true

	case "Mask.Date":
		if e.complexity.Mask.Date == nil {
			break
		}

		return e.complexity.Mask.Date(childComplexity), true

	case "Mask.Reason":
		if e.complexity.Mask.Reason == nil {
			break
		}

		return e.complexity.Mask.Reason(childComplexity), true

	case "Mask.Versions":
		if e.complexity.Mask.Versions == nil {
			break
		}

		return e.complexity.Mask.Versions(childComplexity), true

	case "OutdatedPackage.Atom":
		if e.complexity.OutdatedPackage.Atom == nil {
			break
		}

		return e.complexity.OutdatedPackage.Atom(childComplexity), true

	case "OutdatedPackage.GentooVersion":
		if e.complexity.OutdatedPackage.GentooVersion == nil {
			break
		}

		return e.complexity.OutdatedPackage.GentooVersion(childComplexity), true

	case "OutdatedPackage.NewestVersion":
		if e.complexity.OutdatedPackage.NewestVersion == nil {
			break
		}

		return e.complexity.OutdatedPackage.NewestVersion(childComplexity), true

	case "Package.Atom":
		if e.complexity.Package.Atom == nil {
			break
		}

		return e.complexity.Package.Atom(childComplexity), true

	case "Package.Bugs":
		if e.complexity.Package.Bugs == nil {
			break
		}

		return e.complexity.Package.Bugs(childComplexity), true

	case "Package.Category":
		if e.complexity.Package.Category == nil {
			break
		}

		return e.complexity.Package.Category(childComplexity), true

	case "Package.Commits":
		if e.complexity.Package.Commits == nil {
			break
		}

		return e.complexity.Package.Commits(childComplexity), true

	case "Package.Longdescription":
		if e.complexity.Package.Longdescription == nil {
			break
		}

		return e.complexity.Package.Longdescription(childComplexity), true

	case "Package.Maintainers":
		if e.complexity.Package.Maintainers == nil {
			break
		}

		return e.complexity.Package.Maintainers(childComplexity), true

	case "Package.Name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true

	case "Package.Outdated":
		if e.complexity.Package.Outdated == nil {
			break
		}

		return e.complexity.Package.Outdated(childComplexity), true

	case "Package.PkgCheckResults":
		if e.complexity.Package.PkgCheckResults == nil {
			break
		}

		return e.complexity.Package.PkgCheckResults(childComplexity), true

	case "Package.PrecedingCommits":
		if e.complexity.Package.PrecedingCommits == nil {
			break
		}

		return e.complexity.Package.PrecedingCommits(childComplexity), true

	case "Package.PullRequests":
		if e.complexity.Package.PullRequests == nil {
			break
		}

		return e.complexity.Package.PullRequests(childComplexity), true

	case "Package.ReverseDependencies":
		if e.complexity.Package.ReverseDependencies == nil {
			break
		}

		return e.complexity.Package.ReverseDependencies(childComplexity), true

	case "Package.Versions":
		if e.complexity.Package.Versions == nil {
			break
		}

		return e.complexity.Package.Versions(childComplexity), true

	case "PkgCheckResult.Atom":
		if e.complexity.PkgCheckResult.Atom == nil {
			break
		}

		return e.complexity.PkgCheckResult.Atom(childComplexity), true

	case "PkgCheckResult.CPV":
		if e.complexity.PkgCheckResult.CPV == nil {
			break
		}

		return e.complexity.PkgCheckResult.CPV(childComplexity), true

	case "PkgCheckResult.Category":
		if e.complexity.PkgCheckResult.Category == nil {
			break
		}

		return e.complexity.PkgCheckResult.Category(childComplexity), true

	case "PkgCheckResult.Class":
		if e.complexity.PkgCheckResult.Class == nil {
			break
		}

		return e.complexity.PkgCheckResult.Class(childComplexity), true

	case "PkgCheckResult.Message":
		if e.complexity.PkgCheckResult.Message == nil {
			break
		}

		return e.complexity.PkgCheckResult.Message(childComplexity), true

	case "PkgCheckResult.Package":
		if e.complexity.PkgCheckResult.Package == nil {
			break
		}

		return e.complexity.PkgCheckResult.Package(childComplexity), true

	case "PkgCheckResult.Version":
		if e.complexity.PkgCheckResult.Version == nil {
			break
		}

		return e.complexity.PkgCheckResult.Version(childComplexity), true

	case "Query.addedPackages":
		if e.complexity.Query.AddedPackages == nil {
			break
		}

		args, err := ec.field_Query_addedPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AddedPackages(childComplexity, args["Limit"].(*int)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		return e.complexity.Query.Application(childComplexity), true

	case "Query.categories":
		if e.complexity.Query.Categories == nil {
			break
		}

		args, err := ec.field_Query_categories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Categories(childComplexity, args["Name"].(*string), args["Description"].(*string)), true

	case "Query.category":
		if e.complexity.Query.Category == nil {
			break
		}

		args, err := ec.field_Query_category_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Category(childComplexity, args["Name"].(*string), args["Description"].(*string)), true

	case "Query.commit":
		if e.complexity.Query.Commit == nil {
			break
		}

		args, err := ec.field_Query_commit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Commit(childComplexity, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string)), true

	case "Query.commits":
		if e.complexity.Query.Commits == nil {
			break
		}

		args, err := ec.field_Query_commits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Commits(childComplexity, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string)), true

	case "Query.keywordedVersions":
		if e.complexity.Query.KeywordedVersions == nil {
			break
		}

		args, err := ec.field_Query_keywordedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.KeywordedVersions(childComplexity, args["Limit"].(*int), args["Arch"].(*string)), true

	case "Query.lastCommitTime":
		if e.complexity.Query.LastCommitTime == nil {
			break
		}

		return e.complexity.Query.LastCommitTime(childComplexity), true

	case "Query.mask":
		if e.complexity.Query.Mask == nil {
			break
		}

		args, err := ec.field_Query_mask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Mask(childComplexity, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string)), true

	case "Query.masks":
		if e.complexity.Query.Masks == nil {
			break
		}

		args, err := ec.field_Query_masks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Masks(childComplexity, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string)), true

	case "Query.outdatedPackage":
		if e.complexity.Query.OutdatedPackage == nil {
			break
		}

		args, err := ec.field_Query_outdatedPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutdatedPackage(childComplexity, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string)), true

	case "Query.outdatedPackages":
		if e.complexity.Query.OutdatedPackages == nil {
			break
		}

		args, err := ec.field_Query_outdatedPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutdatedPackages(childComplexity, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string)), true

	case "Query.package":
		if e.complexity.Query.Package == nil {
			break
		}

		args, err := ec.field_Query_package_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Package(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int)), true

	case "Query.pkgCheckResult":
		if e.complexity.Query.PkgCheckResult == nil {
			break
		}

		args, err := ec.field_Query_pkgCheckResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgCheckResult(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string)), true

	case "Query.pkgCheckResults":
		if e.complexity.Query.PkgCheckResults == nil {
			break
		}

		args, err := ec.field_Query_pkgCheckResults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgCheckResults(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string)), true

	case "Query.stabilizedVersions":
		if e.complexity.Query.StabilizedVersions == nil {
			break
		}

		args, err := ec.field_Query_stabilizedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StabilizedVersions(childComplexity, args["Limit"].(*int), args["Arch"].(*string)), true

	case "Query.updatedVersions":
		if e.complexity.Query.UpdatedVersions == nil {
			break
		}

		args, err := ec.field_Query_updatedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpdatedVersions(childComplexity, args["Limit"].(*int)), true

	case "Query.useflag":
		if e.complexity.Query.Useflag == nil {
			break
		}

		args, err := ec.field_Query_useflag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Useflag(childComplexity, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string)), true

	case "Query.useflags":
		if e.complexity.Query.Useflags == nil {
			break
		}

		args, err := ec.field_Query_useflags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Useflags(childComplexity, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string)), true

	case "Query.versions":
		if e.complexity.Query.Versions == nil {
			break
		}

		args, err := ec.field_Query_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Versions(childComplexity, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string)), true

	case "ReverseDependency.Atom":
		if e.complexity.ReverseDependency.Atom == nil {
			break
		}

		return e.complexity.ReverseDependency.Atom(childComplexity), true

	case "ReverseDependency.Condition":
		if e.complexity.ReverseDependency.Condition == nil {
			break
		}

		return e.complexity.ReverseDependency.Condition(childComplexity), true

	case "ReverseDependency.Id":
		if e.complexity.ReverseDependency.Id == nil {
			break
		}

		return e.complexity.ReverseDependency.Id(childComplexity), true

	case "ReverseDependency.ReverseDependencyAtom":
		if e.complexity.ReverseDependency.ReverseDependencyAtom == nil {
			break
		}

		return e.complexity.ReverseDependency.ReverseDependencyAtom(childComplexity), true

	case "ReverseDependency.ReverseDependencyVersion":
		if e.complexity.ReverseDependency.ReverseDependencyVersion == nil {
			break
		}

		return e.complexity.ReverseDependency.ReverseDependencyVersion(childComplexity), true

	case "ReverseDependency.Type":
		if e.complexity.ReverseDependency.Type == nil {
			break
		}

		return e.complexity.ReverseDependency.Type(childComplexity), true

	case "Useflag.Description":
		if e.complexity.Useflag.Description == nil {
			break
		}

		return e.complexity.Useflag.Description(childComplexity), true

	case "Useflag.Id":
		if e.complexity.Useflag.Id == nil {
			break
		}

		return e.complexity.Useflag.Id(childComplexity), true

	case "Useflag.Name":
		if e.complexity.Useflag.Name == nil {
			break
		}

		return e.complexity.Useflag.Name(childComplexity), true

	case "Useflag.Package":
		if e.complexity.Useflag.Package == nil {
			break
		}

		return e.complexity.Useflag.Package(childComplexity), true

	case "Useflag.Scope":
		if e.complexity.Useflag.Scope == nil {
			break
		}

		return e.complexity.Useflag.Scope(childComplexity), true

	case "Useflag.UseExpand":
		if e.complexity.Useflag.UseExpand == nil {
			break
		}

		return e.complexity.Useflag.UseExpand(childComplexity), true

	case "Version.Atom":
		if e.complexity.Version.Atom == nil {
			break
		}

		return e.complexity.Version.Atom(childComplexity), true

	case "Version.Category":
		if e.complexity.Version.Category == nil {
			break
		}

		return e.complexity.Version.Category(childComplexity), true

	case "Version.Commits":
		if e.complexity.Version.Commits == nil {
			break
		}

		return e.complexity.Version.Commits(childComplexity), true

	case "Version.Dependencies":
		if e.complexity.Version.Dependencies == nil {
			break
		}

		return e.complexity.Version.Dependencies(childComplexity), true

	case "Version.Description":
		if e.complexity.Version.Description == nil {
			break
		}

		return e.complexity.Version.Description(childComplexity), true

	case "Version.EAPI":
		if e.complexity.Version.EAPI == nil {
			break
		}

		return e.complexity.Version.EAPI(childComplexity), true

	case "Version.Homepage":
		if e.complexity.Version.Homepage == nil {
			break
		}

		return e.complexity.Version.Homepage(childComplexity), true

	case "Version.Id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true

	case "Version.Keywords":
		if e.complexity.Version.Keywords == nil {
			break
		}

		return e.complexity.Version.Keywords(childComplexity), true

	case "Version.License":
		if e.complexity.Version.License == nil {
			break
		}

		return e.complexity.Version.License(childComplexity), true

	case "Version.Masks":
		if e.complexity.Version.Masks == nil {
			break
		}

		return e.complexity.Version.Masks(childComplexity), true

	case "Version.Package":
		if e.complexity.Version.Package == nil {
			break
		}

		return e.complexity.Version.Package(childComplexity), true

	case "Version.PkgCheckResults":
		if e.complexity.Version.PkgCheckResults == nil {
			break
		}

		return e.complexity.Version.PkgCheckResults(childComplexity), true

	case "Version.Properties":
		if e.complexity.Version.Properties == nil {
			break
		}

		return e.complexity.Version.Properties(childComplexity), true

	case "Version.Restricts":
		if e.complexity.Version.Restricts == nil {
			break
		}

		return e.complexity.Version.Restricts(childComplexity), true

	case "Version.Slot":
		if e.complexity.Version.Slot == nil {
			break
		}

		return e.complexity.Version.Slot(childComplexity), true

	case "Version.Subslot":
		if e.complexity.Version.Subslot == nil {
			break
		}

		return e.complexity.Version.Subslot(childComplexity), true

	case "Version.Useflags":
		if e.complexity.Version.Useflags == nil {
			break
		}

		return e.complexity.Version.Useflags(childComplexity), true

	case "Version.Version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "pkg/api/graphql/schema/directives.graphql", Input: `# GQL Directives
# This part is fairly necessary and is described in the gql documentation
# https://gqlgen.com/config/
directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION
    | FIELD_DEFINITION`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/query.graphql", Input: `"Different queries that can be used to get packages data"
type Query {

    "A query to get a single category by any of the given parameters. Multiple parameters can be used. In case the category can not identified uniquely by the given parameters, an error is returned."
    category(
        "Search by the name of the category"
        Name: String,
        "Search by the description of the category"
        Description: String
    ): Category

    "A query to get a list of categories filtered by the given parameters. The returned list may be empty."
    categories(
        "Search by the name of the category"
        Name: String,
        "Search by the description of the category"
        Description: String
    ): [Category]


    "A query to get a single commit by any of the given parameters. Multiple parameters can be used. In case the commit can not identified uniquely by the given parameters, an error is returned."
    commit(
        "Search by the id that is the hash of the commit"
        Id: String,
        "Search by the number of preceding that were submitted prior to this commit"
        PrecedingCommits: Int,
        "Search by the full name of the author"
        AuthorName: String,
        "Search by the email address of the author"
        AuthorEmail: String,
        "Search by the date of the author"
        AuthorDate: Time,
        "Search by the full name of the committer"
        CommitterName: String,
        "Search by the email address of the committer"
        CommitterEmail: String,
        "Search by the date of the committer"
        CommitterDate: Time,
        "Search by the commit message"
        Message: String
    ): Commit

    "A query to get a list of commits filtered by the given parameters. The returned list may be empty."
    commits(
        "Search by the id that is the hash of the commit"
        Id: String,
        "Search by the number of preceding that were submitted prior to this commit"
        PrecedingCommits: Int,
        "Search by the full name of the author"
        AuthorName: String,
        "Search by the email address of the author"
        AuthorEmail: String,
        "Search by the date of the author"
        AuthorDate: Time,
        "Search by the full name of the committer"
        CommitterName: String,
        "Search by the email address of the committer"
        CommitterEmail: String,
        "Search by the date of the committer"
        CommitterDate: Time,
        "Search by the commit message"
        Message: String
    ): [Commit]


    "A query to get a single mask entry by any of the given parameters. Multiple parameters can be used. In case the mask entry can not identified uniquely by the given parameters, an error is returned."
    mask(
        "Search by the version identifier that has been used to select the masked versions"
        Versions: String,
        "Search by full name of the author of the mask entry"
        Author: String,
        "Search by the email address of the author of the mask entry"
        AuthorEmail: String,
        "Search by the date of the mask entry"
        Date: Time,
        "Search by the specified reason of the mask entry"
        Reason: String
    ): Mask

    "A query to get a list of mask entries filtered by the given parameters. The returned list may be empty."
    masks(
        "Search by the version identifier that has been used to select the masked versions"
        Versions: String,
        "Search by full name of the author of the mask entry"
        Author: String,
        "Search by the email address of the author of the mask entry"
        AuthorEmail: String,
        "Search by the date of the mask entry"
        Date: Time,
        "Search by the specified reason of the mask entry"
        Reason: String
    ): [Mask]


    "A query to get a single outdatedPackage by any of the given parameters. Multiple parameters can be used. In case the outdatedPackage can not identified uniquely by the given parameters, an error is returned."
    outdatedPackage(
        "Search by the atom of the package that is outdated"
        Atom: String,
        "Search by the latest version of the package in Gentoo tree"
        GentooVersion: String,
        "Search by the latest version of the package upstream"
        NewestVersion: String
    ): OutdatedPackage

    "A query to get a list of outdatedPackages filtered by the given parameters. The returned list may be empty."
    outdatedPackages(
        "Search by the atom of the package that is outdated"
        Atom: String,
        "Search by the latest version of the package in Gentoo tree"
        GentooVersion: String,
        "Search by the latest version of the package upstream"
        NewestVersion: String
    ): [OutdatedPackage]


    "A query to get a single pkgCheckResult by any of the given parameters. Multiple parameters can be used. In case the pkgCheckResult can not identified uniquely by the given parameters, an error is returned."
    pkgCheckResult(
        "Search by the package atom of the version that is affected by the pkgcheck result"
        Atom: String,
        "Search by the package category of the version that is affected by the pkgcheck result"
        Category: String,
        "Search by the package name of the version that is affected by the pkgcheck result"
        Package: String,
        "Search by the version identifier of the version that is affected by the pkgcheck result"
        Version: String,
        "Search by the CPV of the version that is affected by the pkgcheck result"
        CPV: String,
        "Search by the class of the pkgcheck warning, e.g. DeprecatedEapi"
        Class: String,
        "Search by the message of the pkgcheck warning, e.g. 'uses deprecated EAPI 5'"
        Message: String
    ): PkgCheckResult

    "A query to get a list of pkgCheckResults filtered by the given parameters. The returned list may be empty."
    pkgCheckResults(
        "Search by the package atom of the version that is affected by the pkgcheck result"
        Atom: String,
        "Search by the package category of the version that is affected by the pkgcheck result"
        Category: String,
        "Search by the package name of the version that is affected by the pkgcheck result"
        Package: String,
        "Search by the version identifier of the version that is affected by the pkgcheck result"
        Version: String,
        "Search by the CPV of the version that is affected by the pkgcheck result"
        CPV: String,
        "Search by the class of the pkgcheck warning, e.g. DeprecatedEapi"
        Class: String,
        "Search by the message of the pkgcheck warning, e.g. 'uses deprecated EAPI 5'"
        Message: String
    ): [PkgCheckResult]


    "A query to get a single package by any of the given parameters. Multiple parameters can be used. In case the package can not identified uniquely by the given parameters, an error is returned."
    package(
        "Search by the atom of the package"
        Atom: String,
        "Search by the category of the package"
        Category: String,
        "Search by the package name of the package"
        Name: String,
        "Search by the long description of the package"
        Longdescription: String,
        "Search by the number of preceding commits before the package was added"
        PrecedingCommits: Int
    ): Package

    "A query to get a list of packages filtered by the given parameters. The returned list may be empty."
    packages(
        "Search by the atom of the package"
        Atom: String,
        "Search by the category of the package"
        Category: String,
        "Search by the package name of the package"
        Name: String,
        "Search by the long description of the package"
        Longdescription: String,
        "Search by the number of preceding commits before the package was added"
        PrecedingCommits: Int
    ): [Package]


    "A query to get a single useflag by any of the given parameters. Multiple parameters can be used. In case the useflag can not identified uniquely by the given parameters, an error is returned."
    useflag(
        "Search by the id of the useflag"
        Id: String,
        "Search by the name of the useflag"
        Name: String,
        "Search by the scope of the useflag, e.g. local or global"
        Scope: String,
        "Search by the description of the useflag"
        Description: String,
        "Search by the use expand"
        UseExpand: String,
        "Search by the package that belongs to the useflag in case it is a local useflag"
        Package: String
    ): Useflag

    "A query to get a list of useflags filtered by the given parameters. The returned list may be empty."
    useflags(
        "Search by the id of the useflag"
        Id: String,
        "Search by the name of the useflag"
        Name: String,
        "Search by the scope of the useflag, e.g. local or global"
        Scope: String,
        "Search by the description of the useflag"
        Description: String,
        "Search by the use expand"
        UseExpand: String,
        "Search by the package that belongs to the useflag in case it is a local useflag"
        Package: String
    ): [Useflag]


    "A query to get a single version by any of the given parameters. Multiple parameters can be used. In case the version can not identified uniquely by the given parameters, an error is returned."
    version(
        "Search by the id of the version"
        Id: String,
        "Search by the category of the package of the version"
        Category: String,
        "Search by the package name of the version"
        Package: String,
        "Search by the atom of the package of the version"
        Atom: String,
        "Search by the version identifier of the version"
        Version: String,
        "Search by the slot of the version"
        Slot: String,
        "Search by the subslot of the version"
        Subslot: String,
        "Search by the EAPI of the ebuild of the version"
        EAPI: String,
        "Search by the keywords of the version"
        Keywords: String,
        "Search by the useflags of the version"
        Useflags: String,
        "Search by the restricts information of the version"
        Restricts: String,
        "Search by the properties of the version"
        Properties: String,
        "Search by the homepage of the version"
        Homepage: String,
        "Search by the license of the version"
        License: String,
        "Search by the description of the version"
        Description: String
    ): Version

    "A query to get a list of versions filtered by the given parameters. The returned list may be empty."
    versions(
        "Search by the id of the version"
        Id: String,
        "Search by the category of the package of the version"
        Category: String,
        "Search by the package name of the version"
        Package: String,
        "Search by the atom of the package of the version"
        Atom: String,
        "Search by the version identifier of the version"
        Version: String,
        "Search by the slot of the version"
        Slot: String,
        "Search by the subslot of the version"
        Subslot: String,
        "Search by the EAPI of the ebuild of the version"
        EAPI: String,
        "Search by the keywords of the version"
        Keywords: String,
        "Search by the useflags of the version"
        Useflags: String,
        "Search by the restricts information of the version"
        Restricts: String,
        "Search by the properties of the version"
        Properties: String,
        "Search by the homepage of the version"
        Homepage: String,
        "Search by the license of the version"
        License: String,
        "Search by the description of the version"
        Description: String
    ): [Version]


    "A query to get the application information."
    application: Application

    "A query to get the last commit time."
    lastCommitTime: Time

    #
    # Shortcuts for convenience and easy migration
    #
    "A query to get the latest added packages. You have to specify the number of added packages that should be returned."
    addedPackages(
        "The number of added packages that should be returned"
        Limit: Int
    ): [Package]

    "A query to get the latest updated versions. You have to specify the number of updated versions that should be returned."
    updatedVersions(
        "The number of updated versions that should be returned"
        Limit: Int
    ): [Version]

    "A query to get the latest stabilized versions. You have to specify the number of stabilized versions that should be returned."
    stabilizedVersions(
        "The number of stabilized versions that should be returned"
        Limit: Int,
        "The arch that should be used to filter the results"
        Arch: String
    ): [Version]

    "A query to get the latest keyworded versions. You have to specify the number of keyworded versions that should be returned."
    keywordedVersions(
        "The number of keyworded versions that should be returned"
        Limit: Int,
        "The arch that should be used to filter the results"
        Arch: String
    ): [Version]
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/scalar.graphql", Input: `# gqlgen supports some custom scalars out of the box
# see: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md

# resolves to time.Time
scalar Time

# resolves to map[string]interface{}
scalar Map

# resolves to interface{}
scalar Any
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/schema.graphql", Input: `schema {
    query: Query
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/Bug.graphql", Input: `"Information about Bugs"
type Bug
  @goModel(
    model: "soko/pkg/models.Bug"
  ) {

  "The id of the bug."
  Id: String!

  "The product of the bug."
  Product: String!

  "The component of the bug."
  Component: String!

  "The assignee of the bug."
  Assignee: String!

  "The status of the bug."
  Status: String!

  "The summary of the bug."
  Summary: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/GithubPullRequest.graphql", Input: `"Information about Github PullRequest"
type GithubPullRequest
  @goModel(
    model: "soko/pkg/models.GithubPullRequest"
  ) {

  "The id of the pull request."
  Id: String!

  "True if the pull request is closed."
  Closed: Boolean!

  "The url of the pull request."
  Url: String!

  "The title of the pull request."
  Title: String!

  "The date of the creation of the pull request."
  CreatedAt: String!

  "The date of the last update of the pull request."
  UpdatedAt: String!

  "The CI state of the pull request."
  CiState: String!

  "The link to the CI state of the pull request."
  CiStateLink: String!

  "The labels of the pull request."
  Labels: [GitHubPullRequestLabelNode!]!

  "The number of comments."
  Comments: Int!

  "The changed files in the pull request11."
  Files: [GitHubPullRequestFileNode!]!

  "The author of the pull request."
  Author: String!
}


"Information about Github PullRequest Labels"
type GitHubPullRequestLabelNode
@goModel(
  model: "soko/pkg/models.GitHubPullRequestLabelNode"
) {

  "The content / name of the label."
  Name: String!

  "The color of the label."
  Color: String!

}



"Information about Github PullRequest changed Files"
type GitHubPullRequestFileNode
@goModel(
  model: "soko/pkg/models.GitHubPullRequestFileNode"
) {

  "The path of the changed file."
  Path: String!

  "The number of additions."
  Additions: Int!

  "The number of deletions."
  Deletions: Int!

}`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/Mask.graphql", Input: `"A package's mask entry"
type Mask
  @goModel(
    model: "soko/pkg/models.Mask"
  ) {

  "A string that describes all versions that are affected by this mask entry"
  Versions: String!

  "The autor of this mask entry"
  Author: String!

  "The email of the author of this mask entry"
  AuthorEmail: String!

  "The date of this mask entry"
  Date: Time!

  "The reason for masking this packages"
  Reason: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/OutdatedPackage.graphql", Input: `"Information from repology about outdated packages in the Gentoo tree."
type OutdatedPackage
  @goModel(
    model: "soko/pkg/models.OutdatedPackages"
  ) {

  "The atom of the affected package"
  Atom: String!

  "The latest version of the package that is present in the Gentoo tree"
  GentooVersion: String!

  "The latest version of the package that is present upstream. This version is greater than the latest version in the Gentoo tree."
  NewestVersion: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/Package.graphql", Input: `"A Gentoo package"
type Package
  @goModel(
    model: "soko/pkg/models.Package"
  ) {

  "The Atom of the package (category/package_name)"
  Atom: String!

  "The category of the package"
  Category: String!

  "The name of the package"
  Name: String!

  "An array containing all versions of package that are present"
  Versions: [Version!]!

  "The Longdescription of the package"
  Longdescription: String!

  "An array containing all maintainers of the package"
  Maintainers: [Maintainer!]!

  "An array containing all commits that have changed files containing to this package"
  Commits: [Commit!]!

  "The number of commits in the tree before the package has been added to the tree - this can be used to sort"
  PrecedingCommits: Int!

  "An array containing all pkgcheck warnings for this package"
  PkgCheckResults: [PkgCheckResult!]!

  "An array containing all repology warnings about new versions for this package"
  Outdated: [OutdatedPackage!]!

  "An array containing all bugs for this package"
  Bugs: [Bug!]!

  "An array containing all pull requests for this package"
  PullRequests: [GithubPullRequest!]!

  "An array containing all reverse dependencies for this package"
  ReverseDependencies: [ReverseDependency!]!
}

"Information about a maintainer of packages"
type Maintainer
  @goModel(
    model: "soko/pkg/models.Maintainer"
  ) {

  "The full name of the maintainer"
  Name: String!

  "The email address of the maintainer"
  Email: String!

  "The type of the maintainer, e.g. project or person"
  Type: String!

  "The restrict information for this maintainer"
  Restrict: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/PkgCheckResult.graphql", Input: `"A warning from pkgcheck for a version of a package"
type PkgCheckResult
  @goModel(
    model: "soko/pkg/models.PkgCheckResult"
  ) {

  "The atom of the package that is affected by this pkgcheck warning"
  Atom: String!

  "The category of the package that is affected by this pkgcheck warning"
  Category: String!

  "The package name of the package that is affected by this pkgcheck warning"
  Package: String!

  "The version of the package that is affected by this pkgcheck warning"
  Version: String!

  "The CPV of the package that is affected by this pkgcheck warning"
  CPV: String!

  "The class of this warning, e.g. DeprecatedEapi"
  Class: String!

  "The message of this warning, e.g. 'uses deprecated EAPI 5'"
  Message: String!
}

`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/ReverseDependency.graphql", Input: `"Information about Reverse Dependencies"
type ReverseDependency
  @goModel(
    model: "soko/pkg/models.ReverseDependency"
  ) {

  "The id."
  Id: String!

  "The atom of the package."
  Atom: String!

  "The type of the dependency."
  Type: String!

  "The atom of the reverse dependency."
  ReverseDependencyAtom: String!

  "The version of the reverse depedency."
  ReverseDependencyVersion: String!

  "The condition for the dependency"
  Condition: String
}`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/Version.graphql", Input: `"A version of a gentoo package"
type Version
  @goModel(
    model: "soko/pkg/models.Version"
  ) {
  "The id i.e. CPV of a version to uniquely identify it"
  Id: String!

  "The category of the package of the version"
  Category: String!

  "The package name of the package of the version"
  Package: String!

  "The atom of the package of the version"
  Atom: String!

  "The version identifier of the version"
  Version: String!

  "The slot of the version"
  Slot: String!

  "The subslot of the version"
  Subslot: String!

  "The EAPI of the ebuild of the version"
  EAPI: String!

  "A string containing all keywords of the version"
  Keywords: String!

  "A list of all useflags of the version"
  Useflags: [String!]!

  "An array of restrict information for this version"
  Restricts: [String!]!

  "All properties of this version"
  Properties: [String!]!

  "An array of homepages of the package of this version"
  Homepage: [String!]!

  "The license of this version of the package"
  License: String!

  "The description of the version of this package"
  Description: String!

  "All commit objects that have affected this version"
  Commits: [Commit!]!

  "All mask entries that affect this version"
  Masks: [Mask!]!

  "An array of all pkgcheck results that affect this version"
  PkgCheckResults: [PkgCheckResult!]!

  "An array containing all dependencies of the version"
  Dependencies: [ReverseDependency!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/application.graphql", Input: `"Contains general information about the application"
type Application
  @goModel(
    model: "soko/pkg/models.Application"
  ) {
  "The version of the currently running application"
  Version: String!

  "The time of the last update of the application data"
  LastUpdate: Time!

  "The id / hash of the last commit that has been imported"
  LastCommit: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/category.graphql", Input: `"Describes a Gentoo package category"
type Category
  @goModel(
    model: "soko/pkg/models.Category"
  ) {
  "The name of the category"
  Name: String!

  "The description of the category"
  Description: String!

  "An array of all packages in this category"
  Packages: [Package!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/commit.graphql", Input: `"A commit in the gentoo.git repository"
type Commit
  @goModel(
    model: "soko/pkg/models.Commit"
  ) {
  "The hash of the commit, that is used to uniquely identify it"
  Id: String!

  "The number of preceding commits before this commit - this can be used to sort commits"
  PrecedingCommits: Int!

  "The full name of the author"
  AuthorName: String!

  "The email name of the author"
  AuthorEmail: String!

  "The date of the author"
  AuthorDate: Time!

  "The name of the committer"
  CommitterName: String!

  "The email name of the committer"
  CommitterEmail: String!

  "The date name of the committer"
  CommitterDate: Time!
  "The message of the commit"
  Message: String!

  "The changed files"
  ChangedFiles: ChangedFiles!

  "An array of packages that are affected by this commit"
  ChangedPackages: [Package!]!

  "An array of versions that are affected by this commit"
  ChangedVersions: [Version!]!

  "An array of KeywordChange objects that are affected by this commit"
  KeywordChanges: [KeywordChange!]!
}

"Describes all files that have been changed by a commit"
type ChangedFiles
@goModel(
  model: "soko/pkg/models.ChangedFiles"
) {
  "All files that have been added by this commit"
  Added: [ChangedFile!]!

  "All files that have been modified by this commit"
  Modified: [ChangedFile!]!

  "All files that have been deleted by this commit"
  Deleted: [ChangedFile!]!
}

"Describes a changed file by a commit"
type ChangedFile
@goModel(
  model: "soko/pkg/models.ChangedFile"
) {
  "The path to the changed file"
  Path: String!

  "The type of the change, e.g. A for added, M for modified or D for deleted"
  ChangeType: String!
}

"A keyword change of a commit"
type KeywordChange
@goModel(
  model: "soko/pkg/models.KeywordChange"
) {
  "The id of the keyword change to uniquely identify the keyword change"
  Id: String!

  "The id / hash of the commit that triggered the keyword change"
  CommitId: String!

  "The commit object of the commit that triggered the keyword change"
  Commit: Commit!

  "The id of the version that is affected by this keyword change"
  VersionId: String!

  "The version object of the version that is affected by this keyword change"
  Version: Version!

  "The id of the package that is affected by this keyword change"
  PackageId: String!

  "The package object of the package that is affected by this keyword change"
  Package: Package!

  "An array of added keywords"
  Added: [String!]!

  "An array of stabilized keywords"
  Stabilized: [String!]!

  "An array of all keywords of the affected version"
  All: [String!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "pkg/api/graphql/schema/types/useflag.graphql", Input: `"A useflag"
type Useflag
  @goModel(
    model: "soko/pkg/models.Useflag"
  ) {

  "The id of the useflag to uniquely identify the useflag"
  Id: ID!

  "The name of the useflag"
  Name: String!

  "The scope of the useflag, e.g. local or global useflag"
  Scope: String!

  "The description of the useflag"
  Description: String!

  "UseExpand, in case it's use expand flag"
  UseExpand: String!

  "The package this useflag belongs to, in case it's a local useflag"
  Package: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_addedPackages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_categories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_category_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_commit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorName"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg3
	var arg4 *time.Time
	if tmp, ok := rawArgs["AuthorDate"]; ok {
		arg4, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorDate"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["CommitterName"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterName"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["CommitterEmail"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterEmail"] = arg6
	var arg7 *time.Time
	if tmp, ok := rawArgs["CommitterDate"]; ok {
		arg7, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterDate"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg8, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_commits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorName"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg3
	var arg4 *time.Time
	if tmp, ok := rawArgs["AuthorDate"]; ok {
		arg4, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorDate"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["CommitterName"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterName"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["CommitterEmail"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterEmail"] = arg6
	var arg7 *time.Time
	if tmp, ok := rawArgs["CommitterDate"]; ok {
		arg7, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterDate"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg8, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_keywordedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Arch"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Arch"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_mask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Versions"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Versions"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Author"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Author"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["Date"]; ok {
		arg3, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Date"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Reason"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Reason"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_masks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Versions"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Versions"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Author"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Author"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["Date"]; ok {
		arg3, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Date"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Reason"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Reason"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_outdatedPackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["GentooVersion"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["GentooVersion"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["NewestVersion"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewestVersion"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_outdatedPackages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["GentooVersion"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["GentooVersion"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["NewestVersion"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewestVersion"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_package_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Longdescription"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Longdescription"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_packages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Longdescription"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Longdescription"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_pkgCheckResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["CPV"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CPV"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Class"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Class"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_pkgCheckResults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["CPV"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CPV"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Class"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Class"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_stabilizedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Arch"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Arch"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_updatedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_useflag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Scope"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Scope"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["UseExpand"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["UseExpand"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_useflags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Scope"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Scope"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["UseExpand"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["UseExpand"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Slot"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Slot"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Subslot"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Subslot"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["EAPI"]; ok {
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["EAPI"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Keywords"]; ok {
		arg8, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Keywords"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["Useflags"]; ok {
		arg9, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Useflags"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["Restricts"]; ok {
		arg10, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Restricts"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["Properties"]; ok {
		arg11, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Properties"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["Homepage"]; ok {
		arg12, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Homepage"] = arg12
	var arg13 *string
	if tmp, ok := rawArgs["License"]; ok {
		arg13, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["License"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg14, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg14
	return args, nil
}

func (ec *executionContext) field_Query_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Slot"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Slot"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Subslot"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Subslot"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["EAPI"]; ok {
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["EAPI"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Keywords"]; ok {
		arg8, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Keywords"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["Useflags"]; ok {
		arg9, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Useflags"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["Restricts"]; ok {
		arg10, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Restricts"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["Properties"]; ok {
		arg11, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Properties"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["Homepage"]; ok {
		arg12, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Homepage"] = arg12
	var arg13 *string
	if tmp, ok := rawArgs["License"]; ok {
		arg13, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["License"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg14, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg14
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Application_Version(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_LastUpdate(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_LastCommit(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCommit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Id(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Product(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Product, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Component(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Component, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Assignee(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Assignee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Status(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Summary(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Name(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Description(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Packages(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Packages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalNPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFile_Path(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFile) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFile",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFile_ChangeType(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFile) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFile",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Added(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Added, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2sokopkgmodelsChangedFile(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Modified(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2sokopkgmodelsChangedFile(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Deleted(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2sokopkgmodelsChangedFile(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_Id(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_PrecedingCommits(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecedingCommits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorName(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorEmail(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorDate(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterName(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterEmail(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterDate(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_Message(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedFiles(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChangedFiles)
	fc.Result = res
	return ec.marshalNChangedFiles2sokopkgmodelsChangedFiles(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedPackages(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalNPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedVersions(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalNVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_KeywordChanges(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeywordChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.KeywordChange)
	fc.Result = res
	return ec.marshalNKeywordChange2sokopkgmodelsKeywordChange(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Path(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Additions(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Additions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Deletions(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deletions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestLabelNode_Name(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestLabelNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestLabelNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestLabelNode_Color(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestLabelNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestLabelNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Id(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Closed(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Closed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Url(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Title(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_UpdatedAt(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CiState(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CiState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CiStateLink(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CiStateLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Labels(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.GitHubPullRequestLabelNode)
	fc.Result = res
	return ec.marshalNGitHubPullRequestLabelNode2sokopkgmodelsGitHubPullRequestLabelNode(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Comments(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Files(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.GitHubPullRequestFileNode)
	fc.Result = res
	return ec.marshalNGitHubPullRequestFileNode2sokopkgmodelsGitHubPullRequestFileNode(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Author(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Id(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_CommitId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Commit(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2sokopkgmodelsCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_VersionId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Version(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Version)
	fc.Result = res
	return ec.marshalNVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_PackageId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Package(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Package)
	fc.Result = res
	return ec.marshalNPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Added(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Added, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Stabilized(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stabilized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_All(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.All, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Name(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Email(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Type(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Restrict(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restrict, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Versions(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Author(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_AuthorEmail(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Date(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Reason(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_Atom(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_GentooVersion(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GentooVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_NewestVersion(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewestVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Atom(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Category(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Name(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Versions(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalNVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Longdescription(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Longdescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Maintainers(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2sokopkgmodelsMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Commits(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2sokopkgmodelsCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PrecedingCommits(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecedingCommits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PkgCheckResults(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PkgCheckResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Outdated(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalNOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Bugs(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bugs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Bug)
	fc.Result = res
	return ec.marshalNBug2sokopkgmodelsBug(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PullRequests(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PullRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.GithubPullRequest)
	fc.Result = res
	return ec.marshalNGithubPullRequest2sokopkgmodelsGithubPullRequest(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_ReverseDependencies(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ReverseDependency)
	fc.Result = res
	return ec.marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Atom(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Category(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Package(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Version(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_CPV(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPV, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Class(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Message(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_category(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_category_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Category(rctx, args["Name"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Category)
	fc.Result = res
	return ec.marshalOCategory2sokopkgmodelsCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_categories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_categories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Categories(rctx, args["Name"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Category)
	fc.Result = res
	return ec.marshalOCategory2sokopkgmodelsCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_commit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_commit_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Commit(rctx, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	fc.Result = res
	return ec.marshalOCommit2sokopkgmodelsCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_commits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_commits_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Commits(rctx, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalOCommit2sokopkgmodelsCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_mask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_mask_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Mask(rctx, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Mask)
	fc.Result = res
	return ec.marshalOMask2sokopkgmodelsMask(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_masks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_masks_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Masks(rctx, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Mask)
	fc.Result = res
	return ec.marshalOMask2sokopkgmodelsMask(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_outdatedPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_outdatedPackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutdatedPackage(rctx, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_outdatedPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_outdatedPackages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutdatedPackages(rctx, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_pkgCheckResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_pkgCheckResult_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PkgCheckResult(rctx, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_pkgCheckResults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_pkgCheckResults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PkgCheckResults(rctx, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_package(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_package_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Package(rctx, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Package)
	fc.Result = res
	return ec.marshalOPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_packages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_packages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Packages(rctx, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalOPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_useflag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_useflag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Useflag(rctx, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Useflag)
	fc.Result = res
	return ec.marshalOUseflag2sokopkgmodelsUseflag(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_useflags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_useflags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Useflags(rctx, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Useflag)
	fc.Result = res
	return ec.marshalOUseflag2sokopkgmodelsUseflag(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_version_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Version)
	fc.Result = res
	return ec.marshalOVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_versions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_versions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Versions(rctx, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Application)
	fc.Result = res
	return ec.marshalOApplication2sokopkgmodelsApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_lastCommitTime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LastCommitTime(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_addedPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_addedPackages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AddedPackages(rctx, args["Limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalOPackage2sokopkgmodelsPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_updatedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_updatedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpdatedVersions(rctx, args["Limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_stabilizedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_stabilizedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StabilizedVersions(rctx, args["Limit"].(*int), args["Arch"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_keywordedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_keywordedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KeywordedVersions(rctx, args["Limit"].(*int), args["Arch"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2sokopkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Id(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Atom(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Type(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_ReverseDependencyAtom(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencyAtom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_ReverseDependencyVersion(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencyVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Condition(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Id(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Name(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Scope(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Description(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_UseExpand(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseExpand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Package(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Id(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Category(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Package(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Atom(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Version(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Slot(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Subslot(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subslot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_EAPI(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EAPI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Keywords(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Useflags(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Useflags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Restricts(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Properties(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Homepage(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Homepage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_License(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.License, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Description(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Commits(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2sokopkgmodelsCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Masks(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Masks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Mask)
	fc.Result = res
	return ec.marshalNMask2sokopkgmodelsMask(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_PkgCheckResults(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PkgCheckResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Dependencies(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ReverseDependency)
	fc.Result = res
	return ec.marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationImplementors = []string{"Application"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *models.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "Version":
			out.Values[i] = ec._Application_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastUpdate":
			out.Values[i] = ec._Application_LastUpdate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastCommit":
			out.Values[i] = ec._Application_LastCommit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var bugImplementors = []string{"Bug"}

func (ec *executionContext) _Bug(ctx context.Context, sel ast.SelectionSet, obj *models.Bug) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bugImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bug")
		case "Id":
			out.Values[i] = ec._Bug_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Product":
			out.Values[i] = ec._Bug_Product(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Component":
			out.Values[i] = ec._Bug_Component(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Assignee":
			out.Values[i] = ec._Bug_Assignee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Status":
			out.Values[i] = ec._Bug_Status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Summary":
			out.Values[i] = ec._Bug_Summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryImplementors = []string{"Category"}

func (ec *executionContext) _Category(ctx context.Context, sel ast.SelectionSet, obj *models.Category) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Category")
		case "Name":
			out.Values[i] = ec._Category_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Category_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Packages":
			out.Values[i] = ec._Category_Packages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changedFileImplementors = []string{"ChangedFile"}

func (ec *executionContext) _ChangedFile(ctx context.Context, sel ast.SelectionSet, obj *models.ChangedFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changedFileImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangedFile")
		case "Path":
			out.Values[i] = ec._ChangedFile_Path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangeType":
			out.Values[i] = ec._ChangedFile_ChangeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changedFilesImplementors = []string{"ChangedFiles"}

func (ec *executionContext) _ChangedFiles(ctx context.Context, sel ast.SelectionSet, obj *models.ChangedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changedFilesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangedFiles")
		case "Added":
			out.Values[i] = ec._ChangedFiles_Added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Modified":
			out.Values[i] = ec._ChangedFiles_Modified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Deleted":
			out.Values[i] = ec._ChangedFiles_Deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitImplementors = []string{"Commit"}

func (ec *executionContext) _Commit(ctx context.Context, sel ast.SelectionSet, obj *models.Commit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Commit")
		case "Id":
			out.Values[i] = ec._Commit_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PrecedingCommits":
			out.Values[i] = ec._Commit_PrecedingCommits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorName":
			out.Values[i] = ec._Commit_AuthorName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorEmail":
			out.Values[i] = ec._Commit_AuthorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorDate":
			out.Values[i] = ec._Commit_AuthorDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterName":
			out.Values[i] = ec._Commit_CommitterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterEmail":
			out.Values[i] = ec._Commit_CommitterEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterDate":
			out.Values[i] = ec._Commit_CommitterDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Message":
			out.Values[i] = ec._Commit_Message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedFiles":
			out.Values[i] = ec._Commit_ChangedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedPackages":
			out.Values[i] = ec._Commit_ChangedPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedVersions":
			out.Values[i] = ec._Commit_ChangedVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "KeywordChanges":
			out.Values[i] = ec._Commit_KeywordChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitHubPullRequestFileNodeImplementors = []string{"GitHubPullRequestFileNode"}

func (ec *executionContext) _GitHubPullRequestFileNode(ctx context.Context, sel ast.SelectionSet, obj *models.GitHubPullRequestFileNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubPullRequestFileNodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubPullRequestFileNode")
		case "Path":
			out.Values[i] = ec._GitHubPullRequestFileNode_Path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Additions":
			out.Values[i] = ec._GitHubPullRequestFileNode_Additions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Deletions":
			out.Values[i] = ec._GitHubPullRequestFileNode_Deletions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitHubPullRequestLabelNodeImplementors = []string{"GitHubPullRequestLabelNode"}

func (ec *executionContext) _GitHubPullRequestLabelNode(ctx context.Context, sel ast.SelectionSet, obj *models.GitHubPullRequestLabelNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubPullRequestLabelNodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubPullRequestLabelNode")
		case "Name":
			out.Values[i] = ec._GitHubPullRequestLabelNode_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Color":
			out.Values[i] = ec._GitHubPullRequestLabelNode_Color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubPullRequestImplementors = []string{"GithubPullRequest"}

func (ec *executionContext) _GithubPullRequest(ctx context.Context, sel ast.SelectionSet, obj *models.GithubPullRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPullRequestImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPullRequest")
		case "Id":
			out.Values[i] = ec._GithubPullRequest_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Closed":
			out.Values[i] = ec._GithubPullRequest_Closed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Url":
			out.Values[i] = ec._GithubPullRequest_Url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Title":
			out.Values[i] = ec._GithubPullRequest_Title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreatedAt":
			out.Values[i] = ec._GithubPullRequest_CreatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UpdatedAt":
			out.Values[i] = ec._GithubPullRequest_UpdatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CiState":
			out.Values[i] = ec._GithubPullRequest_CiState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CiStateLink":
			out.Values[i] = ec._GithubPullRequest_CiStateLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Labels":
			out.Values[i] = ec._GithubPullRequest_Labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Comments":
			out.Values[i] = ec._GithubPullRequest_Comments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Files":
			out.Values[i] = ec._GithubPullRequest_Files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Author":
			out.Values[i] = ec._GithubPullRequest_Author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var keywordChangeImplementors = []string{"KeywordChange"}

func (ec *executionContext) _KeywordChange(ctx context.Context, sel ast.SelectionSet, obj *models.KeywordChange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, keywordChangeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeywordChange")
		case "Id":
			out.Values[i] = ec._KeywordChange_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitId":
			out.Values[i] = ec._KeywordChange_CommitId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commit":
			out.Values[i] = ec._KeywordChange_Commit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "VersionId":
			out.Values[i] = ec._KeywordChange_VersionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._KeywordChange_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PackageId":
			out.Values[i] = ec._KeywordChange_PackageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._KeywordChange_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Added":
			out.Values[i] = ec._KeywordChange_Added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Stabilized":
			out.Values[i] = ec._KeywordChange_Stabilized(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "All":
			out.Values[i] = ec._KeywordChange_All(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *models.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "Name":
			out.Values[i] = ec._Maintainer_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Email":
			out.Values[i] = ec._Maintainer_Email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._Maintainer_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Restrict":
			out.Values[i] = ec._Maintainer_Restrict(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maskImplementors = []string{"Mask"}

func (ec *executionContext) _Mask(ctx context.Context, sel ast.SelectionSet, obj *models.Mask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maskImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mask")
		case "Versions":
			out.Values[i] = ec._Mask_Versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Author":
			out.Values[i] = ec._Mask_Author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorEmail":
			out.Values[i] = ec._Mask_AuthorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Date":
			out.Values[i] = ec._Mask_Date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Reason":
			out.Values[i] = ec._Mask_Reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outdatedPackageImplementors = []string{"OutdatedPackage"}

func (ec *executionContext) _OutdatedPackage(ctx context.Context, sel ast.SelectionSet, obj *models.OutdatedPackages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outdatedPackageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutdatedPackage")
		case "Atom":
			out.Values[i] = ec._OutdatedPackage_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "GentooVersion":
			out.Values[i] = ec._OutdatedPackage_GentooVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "NewestVersion":
			out.Values[i] = ec._OutdatedPackage_NewestVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *models.Package) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "Atom":
			out.Values[i] = ec._Package_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._Package_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Name":
			out.Values[i] = ec._Package_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Versions":
			out.Values[i] = ec._Package_Versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Longdescription":
			out.Values[i] = ec._Package_Longdescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Maintainers":
			out.Values[i] = ec._Package_Maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commits":
			out.Values[i] = ec._Package_Commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PrecedingCommits":
			out.Values[i] = ec._Package_PrecedingCommits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PkgCheckResults":
			out.Values[i] = ec._Package_PkgCheckResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Outdated":
			out.Values[i] = ec._Package_Outdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Bugs":
			out.Values[i] = ec._Package_Bugs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PullRequests":
			out.Values[i] = ec._Package_PullRequests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencies":
			out.Values[i] = ec._Package_ReverseDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pkgCheckResultImplementors = []string{"PkgCheckResult"}

func (ec *executionContext) _PkgCheckResult(ctx context.Context, sel ast.SelectionSet, obj *models.PkgCheckResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pkgCheckResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PkgCheckResult")
		case "Atom":
			out.Values[i] = ec._PkgCheckResult_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._PkgCheckResult_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._PkgCheckResult_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._PkgCheckResult_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CPV":
			out.Values[i] = ec._PkgCheckResult_CPV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Class":
			out.Values[i] = ec._PkgCheckResult_Class(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Message":
			out.Values[i] = ec._PkgCheckResult_Message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "category":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_category(ctx, field)
				return res
			})
		case "categories":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_categories(ctx, field)
				return res
			})
		case "commit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_commit(ctx, field)
				return res
			})
		case "commits":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_commits(ctx, field)
				return res
			})
		case "mask":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mask(ctx, field)
				return res
			})
		case "masks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_masks(ctx, field)
				return res
			})
		case "outdatedPackage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outdatedPackage(ctx, field)
				return res
			})
		case "outdatedPackages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outdatedPackages(ctx, field)
				return res
			})
		case "pkgCheckResult":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pkgCheckResult(ctx, field)
				return res
			})
		case "pkgCheckResults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pkgCheckResults(ctx, field)
				return res
			})
		case "package":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_package(ctx, field)
				return res
			})
		case "packages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_packages(ctx, field)
				return res
			})
		case "useflag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_useflag(ctx, field)
				return res
			})
		case "useflags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_useflags(ctx, field)
				return res
			})
		case "version":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				return res
			})
		case "versions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_versions(ctx, field)
				return res
			})
		case "application":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_application(ctx, field)
				return res
			})
		case "lastCommitTime":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_lastCommitTime(ctx, field)
				return res
			})
		case "addedPackages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_addedPackages(ctx, field)
				return res
			})
		case "updatedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_updatedVersions(ctx, field)
				return res
			})
		case "stabilizedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stabilizedVersions(ctx, field)
				return res
			})
		case "keywordedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_keywordedVersions(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var reverseDependencyImplementors = []string{"ReverseDependency"}

func (ec *executionContext) _ReverseDependency(ctx context.Context, sel ast.SelectionSet, obj *models.ReverseDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reverseDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReverseDependency")
		case "Id":
			out.Values[i] = ec._ReverseDependency_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Atom":
			out.Values[i] = ec._ReverseDependency_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._ReverseDependency_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencyAtom":
			out.Values[i] = ec._ReverseDependency_ReverseDependencyAtom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencyVersion":
			out.Values[i] = ec._ReverseDependency_ReverseDependencyVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Condition":
			out.Values[i] = ec._ReverseDependency_Condition(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var useflagImplementors = []string{"Useflag"}

func (ec *executionContext) _Useflag(ctx context.Context, sel ast.SelectionSet, obj *models.Useflag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useflagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Useflag")
		case "Id":
			out.Values[i] = ec._Useflag_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Name":
			out.Values[i] = ec._Useflag_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Scope":
			out.Values[i] = ec._Useflag_Scope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Useflag_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UseExpand":
			out.Values[i] = ec._Useflag_UseExpand(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._Useflag_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *models.Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "Id":
			out.Values[i] = ec._Version_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._Version_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._Version_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Atom":
			out.Values[i] = ec._Version_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._Version_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Slot":
			out.Values[i] = ec._Version_Slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Subslot":
			out.Values[i] = ec._Version_Subslot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "EAPI":
			out.Values[i] = ec._Version_EAPI(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Keywords":
			out.Values[i] = ec._Version_Keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Useflags":
			out.Values[i] = ec._Version_Useflags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Restricts":
			out.Values[i] = ec._Version_Restricts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Properties":
			out.Values[i] = ec._Version_Properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Homepage":
			out.Values[i] = ec._Version_Homepage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "License":
			out.Values[i] = ec._Version_License(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Version_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commits":
			out.Values[i] = ec._Version_Commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Masks":
			out.Values[i] = ec._Version_Masks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PkgCheckResults":
			out.Values[i] = ec._Version_PkgCheckResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Dependencies":
			out.Values[i] = ec._Version_Dependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNBug2sokopkgmodelsBug(ctx context.Context, sel ast.SelectionSet, v models.Bug) graphql.Marshaler {
	return ec._Bug(ctx, sel, &v)
}

func (ec *executionContext) marshalNBug2sokopkgmodelsBug(ctx context.Context, sel ast.SelectionSet, v []*models.Bug) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBug2sokopkgmodelsBug(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNBug2sokopkgmodelsBug(ctx context.Context, sel ast.SelectionSet, v *models.Bug) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Bug(ctx, sel, v)
}

func (ec *executionContext) marshalNChangedFile2sokopkgmodelsChangedFile(ctx context.Context, sel ast.SelectionSet, v models.ChangedFile) graphql.Marshaler {
	return ec._ChangedFile(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangedFile2sokopkgmodelsChangedFile(ctx context.Context, sel ast.SelectionSet, v []*models.ChangedFile) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangedFile2sokopkgmodelsChangedFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChangedFile2sokopkgmodelsChangedFile(ctx context.Context, sel ast.SelectionSet, v *models.ChangedFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangedFile(ctx, sel, v)
}

func (ec *executionContext) marshalNChangedFiles2sokopkgmodelsChangedFiles(ctx context.Context, sel ast.SelectionSet, v models.ChangedFiles) graphql.Marshaler {
	return ec._ChangedFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangedFiles2sokopkgmodelsChangedFiles(ctx context.Context, sel ast.SelectionSet, v *models.ChangedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v []*models.Commit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCommit2sokopkgmodelsCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) marshalNGitHubPullRequestFileNode2sokopkgmodelsGitHubPullRequestFileNode(ctx context.Context, sel ast.SelectionSet, v models.GitHubPullRequestFileNode) graphql.Marshaler {
	return ec._GitHubPullRequestFileNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubPullRequestFileNode2sokopkgmodelsGitHubPullRequestFileNode(ctx context.Context, sel ast.SelectionSet, v []models.GitHubPullRequestFileNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubPullRequestFileNode2sokopkgmodelsGitHubPullRequestFileNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGitHubPullRequestLabelNode2sokopkgmodelsGitHubPullRequestLabelNode(ctx context.Context, sel ast.SelectionSet, v models.GitHubPullRequestLabelNode) graphql.Marshaler {
	return ec._GitHubPullRequestLabelNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubPullRequestLabelNode2sokopkgmodelsGitHubPullRequestLabelNode(ctx context.Context, sel ast.SelectionSet, v []models.GitHubPullRequestLabelNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubPullRequestLabelNode2sokopkgmodelsGitHubPullRequestLabelNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGithubPullRequest2sokopkgmodelsGithubPullRequest(ctx context.Context, sel ast.SelectionSet, v models.GithubPullRequest) graphql.Marshaler {
	return ec._GithubPullRequest(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubPullRequest2sokopkgmodelsGithubPullRequest(ctx context.Context, sel ast.SelectionSet, v []*models.GithubPullRequest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubPullRequest2sokopkgmodelsGithubPullRequest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGithubPullRequest2sokopkgmodelsGithubPullRequest(ctx context.Context, sel ast.SelectionSet, v *models.GithubPullRequest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GithubPullRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNKeywordChange2sokopkgmodelsKeywordChange(ctx context.Context, sel ast.SelectionSet, v models.KeywordChange) graphql.Marshaler {
	return ec._KeywordChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNKeywordChange2sokopkgmodelsKeywordChange(ctx context.Context, sel ast.SelectionSet, v []*models.KeywordChange) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKeywordChange2sokopkgmodelsKeywordChange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNKeywordChange2sokopkgmodelsKeywordChange(ctx context.Context, sel ast.SelectionSet, v *models.KeywordChange) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KeywordChange(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2sokopkgmodelsMaintainer(ctx context.Context, sel ast.SelectionSet, v models.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2sokopkgmodelsMaintainer(ctx context.Context, sel ast.SelectionSet, v []*models.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2sokopkgmodelsMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2sokopkgmodelsMaintainer(ctx context.Context, sel ast.SelectionSet, v *models.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v models.Mask) graphql.Marshaler {
	return ec._Mask(ctx, sel, &v)
}

func (ec *executionContext) marshalNMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v []*models.Mask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMask2sokopkgmodelsMask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v *models.Mask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Mask(ctx, sel, v)
}

func (ec *executionContext) marshalNOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v models.OutdatedPackages) graphql.Marshaler {
	return ec._OutdatedPackage(ctx, sel, &v)
}

func (ec *executionContext) marshalNOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v []*models.OutdatedPackages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v *models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutdatedPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v models.Package) graphql.Marshaler {
	return ec._Package(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v []*models.Package) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPackage2sokopkgmodelsPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v *models.Package) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v models.PkgCheckResult) graphql.Marshaler {
	return ec._PkgCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v []*models.PkgCheckResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v *models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PkgCheckResult(ctx, sel, v)
}

func (ec *executionContext) marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx context.Context, sel ast.SelectionSet, v models.ReverseDependency) graphql.Marshaler {
	return ec._ReverseDependency(ctx, sel, &v)
}

func (ec *executionContext) marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx context.Context, sel ast.SelectionSet, v []*models.ReverseDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNReverseDependency2sokopkgmodelsReverseDependency(ctx context.Context, sel ast.SelectionSet, v *models.ReverseDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ReverseDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v models.Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v []*models.Version) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2sokopkgmodelsVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v *models.Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplication2sokopkgmodelsApplication(ctx context.Context, sel ast.SelectionSet, v models.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalOApplication2sokopkgmodelsApplication(ctx context.Context, sel ast.SelectionSet, v *models.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOCategory2sokopkgmodelsCategory(ctx context.Context, sel ast.SelectionSet, v models.Category) graphql.Marshaler {
	return ec._Category(ctx, sel, &v)
}

func (ec *executionContext) marshalOCategory2sokopkgmodelsCategory(ctx context.Context, sel ast.SelectionSet, v []*models.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCategory2sokopkgmodelsCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCategory2sokopkgmodelsCategory(ctx context.Context, sel ast.SelectionSet, v *models.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Category(ctx, sel, v)
}

func (ec *executionContext) marshalOCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalOCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v []*models.Commit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCommit2sokopkgmodelsCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCommit2sokopkgmodelsCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v models.Mask) graphql.Marshaler {
	return ec._Mask(ctx, sel, &v)
}

func (ec *executionContext) marshalOMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v []*models.Mask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMask2sokopkgmodelsMask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMask2sokopkgmodelsMask(ctx context.Context, sel ast.SelectionSet, v *models.Mask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Mask(ctx, sel, v)
}

func (ec *executionContext) marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v models.OutdatedPackages) graphql.Marshaler {
	return ec._OutdatedPackage(ctx, sel, &v)
}

func (ec *executionContext) marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v []*models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOutdatedPackage2sokopkgmodelsOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v *models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OutdatedPackage(ctx, sel, v)
}

func (ec *executionContext) marshalOPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v models.Package) graphql.Marshaler {
	return ec._Package(ctx, sel, &v)
}

func (ec *executionContext) marshalOPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v []*models.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackage2sokopkgmodelsPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPackage2sokopkgmodelsPackage(ctx context.Context, sel ast.SelectionSet, v *models.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v models.PkgCheckResult) graphql.Marshaler {
	return ec._PkgCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v []*models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPkgCheckResult2sokopkgmodelsPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v *models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PkgCheckResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeTime(ctx, sel, *v)
}

func (ec *executionContext) marshalOUseflag2sokopkgmodelsUseflag(ctx context.Context, sel ast.SelectionSet, v models.Useflag) graphql.Marshaler {
	return ec._Useflag(ctx, sel, &v)
}

func (ec *executionContext) marshalOUseflag2sokopkgmodelsUseflag(ctx context.Context, sel ast.SelectionSet, v []*models.Useflag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUseflag2sokopkgmodelsUseflag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUseflag2sokopkgmodelsUseflag(ctx context.Context, sel ast.SelectionSet, v *models.Useflag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Useflag(ctx, sel, v)
}

func (ec *executionContext) marshalOVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v models.Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalOVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v []*models.Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVersion2sokopkgmodelsVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOVersion2sokopkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v *models.Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
